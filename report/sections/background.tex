The purpose of this section is to familiarize the reader with the mathematical foundations of the Diffie-Hellman key exchange and which algorithms we used to achieve this task. This chapter follows a bottom-up approach.

\mypar{Finite Field arithmetic \cite[p. 3-4]{Brown:2009}} For elliptic curve cryptography one is mainly interested in the prime finite field $\mathbb{F}_p$ and the characteristic 2 finite field $\mathbb{F}_{2^m}$. In this paper only elliptic curves over $\mathbb{F}_p$ are discussed.

\mypar{Montgomery multiplication} 
\\The Montgomery modular multiplication algorithm allows to perform fast modular multiplication on large integers. In particular, the algorithm can be adapted for multi-precision arithmetic. Given two integers $x,y \in \mathbb{F}_p$, the algorithm computes $xy$ mod $p$. In order to perform the modular multiplication, $x$ and $y$ are converted to Montgomery form: $X = xR$ mod $p$ and $Y = yR$ mod $p$ where $R$ is larger than $p$ and co-prime with $p$. $R$ is usually chosen as $b^{t}$ where $b$ matches the size of a processor's word, $2^{64}$ in our case. The algorithm performs a chain of multiplication mod $b$ and division by $b$, which are simply mask and shift operations when $b$ is in the appropriate form. The algorithm for the multi-precision representation is given below \cite[p. 602]{Menezes:1996}


\begin{lstlisting}[frame=single, mathescape=true, captionpos=b, caption=Mulitprecision Montogmery Modular Multiplication ]
Input: 
p = $p_{n-1}$ ... $p_{0}$)$_{b}$
X = ($x_{n-1}$ ... $x_{0}$)$_{b}$
Y = ($y_{n-1}$ ... $y_{0}$)$_{b}$

Output:
$XYR^{-1}$ mod $p$

1. A $\leftarrow$ 0 (A = ($a_n$ ... $a_{0}$)$_{b}$
2. For $i$ from $0$ to $(n-1)$ do:
	2.1 $u_{i} \leftarrow (a_{0}+x_{i}y_{0})p'$ mod $b$
	2.2 $A \leftarrow (A+ x_{i}y + u_{i}p) / b$
3. If $A \geq p$ then $A \leftarrow A-p$
4. Return $A$
\end{lstlisting}

The challenging part of the reduction modulo $p$ resides in the high amount of division operations to be performed. The algorithm takes advantage of the underlying architecture by performing operations on machine words. The modulo operation in itself is only executed at the end, where $A$ is certain to be between $0$ and $2p-1$. (In the early phase of the project, we used a base $b=2$ for $R$). \emph{should be mentioned in section 3.}

\mypar{Shifting using vector instructions} 

The shift operation is used extensively in both our division and Montgomery multiplication algorithm. In the first implementation, we relied on multi-precision division which executes many shift-by-1-bit operations. Although the idea of using vector instruction can sound appealing, we did not see a major speed up when vectorizing the shift operation. The reason for this is that the shift needs to be performed across the vector and therefore also between two vector. This significantly slows the operation since the bits need to be moved between vectors but also across inner boundaries or vectors.

\mypar{Elliptic Curve over $\mathbb{F}_p$ \cite[p. 6-7]{Brown:2009}}
An elliptic curve is defined by the equation
\begin{equation}\label{eq:defining_eq_ec}
y^2 \equiv x^3 + ax + b \quad (\text{mod } p)
\end{equation}
where $p$ is an odd prime number and $a,b \in \mathbb{F}_p$ are the parameters of the curve. Furthermore $a, b$ need to satisfy $4a^3 + 27b^2 \not\equiv 0$. The elliptic curve $E\left(\mathbb{F}_p\right)$ consists of the Points $P=(x,y)$ $x,y \in \mathbb{F}_p$ satisfying (\ref{eq:defining_eq_ec}). Additionally we introduce $\mathcal{O}$ the so called point at infinity. The addition of points (affine coordinates) is defined as follows \cite{Brown:2009}
\begin{enumerate}
\item{$\mathcal{O} + \mathcal{O} = \mathcal{O}$}
\item{$(x,y) + \mathcal{O} = \mathcal{O} + (x,y) = (x,y) \quad \forall (x,y) \in E(\mathbb{F}_p)$}
\item{$(x,y) + (x,-y) = \mathcal{O} \quad \forall (x,y) \in E(\mathbb{F}_p)$}
\item{Assume  $x_1 \neq x_2$. $(x_1, y_1) + (x_2, y_2) = (x_3, y_3)$ is defined as $x_3 \equiv \lambda^2 - x_1 - x_2 \, (\text{mod } p),$ \\ $y_3 \equiv \lambda(x_1 - x_3) - y_1 \, (\text{mod } p)$ and $\lambda \equiv \frac{y_2 - y_1}{x_2 - x_1} \, (\text{mod } p)$}
\item{$(x_1, y_1) + (x_1, y_1) = (x_3, y_3)$ is defined as $x_3 \equiv \lambda^2 -2 x_1 \, (\text{mod } p)$, $\lambda (x_1 - x_3) - y_1  \, (\text{mod } p)$ and $\lambda \equiv \frac{3 x_1^2 + a}{2y_1} \, (\text{mod } p)$}
\end{enumerate}
Rule 4. describes how to add two different points whereas rule 5. explains how to double a point. The set of points satisfying (\ref{eq:defining_eq_ec}) and $\mathcal{O}$ together with this addition form a commutative group.

\mypar{Jacobian Coordinates  \cite[p. 59 - 60]{Blake:1999}}
"In cases where field inversions are significantly more expensive than multiplications, it is efficient to implement projective coordinates" \cite{Blake:1999} In Jacobian coordinates a point is represented as a triplet $(x,y,z)$ satisfying (\ref{eq:defining_eq_ec_jacobians}).
\begin{equation}\label{eq:defining_eq_ec_jacobians}
y^2 \equiv x^3 + axz^4 + bz^6 \quad (\text{mod } p)
\end{equation}
In this project Jacobian coordinates were implemented. For the definition of the rules see \cite[p. 59-60]{Blake:1999}

\mypar{Double-and-add method}
In order to implement the Diffie-Hellman key exchange we need to calculate $dP$ fast.

\begin{lstlisting}[frame=single, mathescape=true, captionpos=b, caption=double-and-add method]
Input: $P \in E(\mathbb{F}_p)$, $d \in \mathbb{N}$\\
Output: $d\cdot P \in E(\mathbb{F}_p)$

$N$ $\leftarrow$ $P$
$Q$ $\leftarrow$ $\mathcal{O}$
for i from 0 to m do
  if $d_i$ = 1 then
    $Q$ $\leftarrow$ point_add($Q$, $N$)
  $N$ $\leftarrow$ point_double($N$)
return $Q$
\end{lstlisting}
where $d = d_0 + d_1 2 + ... + d_m 2^m \quad d_i \, \in \{0,1\}$

\mypar{Diffie Hellman key exchange \cite[p. 170-171]{Washington:2008}}
Alice and Bob want to establish a secret over a public channel. We assume that the elliptic curve parameter: a prime $p$, $a, b \in \mathbb{F}_p$ a point $G$ with high order are publicly known.
\begin{enumerate}
\item{Alice chooses a secret integer $u$, computes $G_u = uG$, and sends $G_u$ to Bob.}
\item{Bob chooses a secret integer $v$, computes $G_v = vG$, and sends $G_v$ to Alice.}
\item{Alice computes $uG_v = uvG$}
\item{Bob computes $vG_u = vuG$.}
\end{enumerate}
One can verify that $uG_v = uvG = vuG = v G_u$. An eavesdropper knows $G, G_u, G_v$ and his goal is to calculate $uvG$. This is known as the Diffie-Hellman Problem and is assumed to be a hard problem. 

\mypar{Complexity}

\mypar{Cost measure}